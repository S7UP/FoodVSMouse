using System.Collections;
using System.Collections.Generic;

using UnityEngine;
using UnityEngine.UIElements;

using static UnityEngine.GraphicsBuffer;

public class FoodUnit : BaseUnit
{
    // 美食单位的属性
    [System.Serializable]
    new public struct Attribute
    {
        public BaseUnit.Attribute baseAttrbute;
        public float[] valueList; // 每级对应数值
        public FoodType foodType;
    }

    // Awake获取的组件
    protected Animator animator;
    protected Animator rankAnimator;
    protected FoodUnit.Attribute attr;
    private SpriteRenderer spriteRenderer1;
    private SpriteRenderer spriteRenderer2;
    private Material defaultMaterial;

    // 其他
    public FoodType mFoodType; // 美食职业划分
    public int mLevel; //星级

    private BaseGrid mGrid; // 卡片所在的格子（单格卡)
    private List<BaseGrid> mGridList; // 卡片所在的格子（多格卡）
    public bool isUseSingleGrid; // 是否只占一格


    public override void Awake()
    {
        base.Awake();
        animator = transform.Find("Ani_Food").gameObject.GetComponent<Animator>();
        rankAnimator = transform.Find("Ani_Rank").gameObject.GetComponent<Animator>();
        spriteRenderer1 = transform.Find("Ani_Food").gameObject.GetComponent<SpriteRenderer>();
        spriteRenderer2 = transform.Find("Ani_Rank").gameObject.GetComponent<SpriteRenderer>();
        defaultMaterial = spriteRenderer1.material;
    }

    // 单位被对象池回收时触发
    public override void OnDisable()
    {
        base.OnDisable();
        mFoodType = 0; // 美食职业划分
        mGrid = null; // 卡片所在的格子（单格卡)
        mGridList = null; // 卡片所在的格子（多格卡）
        isUseSingleGrid = false; // 是否只占一格
        spriteRenderer1.material = defaultMaterial; // 换回来
    }

    // 每次对象被创建时要做的初始化工作
    public override void MInit()
    {
        base.MInit();
        
        attr = GameController.Instance.GetFoodAttribute();
        mFoodType = attr.foodType;

        mGridList = new List<BaseGrid>();
        isUseSingleGrid = true;

        animator.runtimeAnimatorController = GameManager.Instance.GetRuntimeAnimatorController("Food/"+mType+"/"+mShape);
        SetActionState(new IdleState(this));

        SetLevel(6);

        spriteRenderer2.enabled = true; // 激活星级动画
        AnimatorContinue(); // 恢复播放动画
    }

    public override void SetUnitType()
    {
        mUnitType = UnitType.Food;
    }

    public void SetLevel(int level)
    {
        mLevel = level;
        UpdateAttributeByLevel();
        rankAnimator.Play(mLevel.ToString()); // 先播放星级的图标动画
    }

    /// <summary>
    /// 根据等级表和等级来更新对应数据
    /// </summary>
    public virtual void UpdateAttributeByLevel()
    {

    }

    /// <summary>
    /// 加载技能，此处仅加载普通攻击，具体技能加载实现请在子类中重写
    /// </summary>
    public override void LoadSkillAbility()
    {
        foreach (var item in AbilityManager.Instance.GetSkillAbilityInfoList(mUnitType, mType, mShape))
        {
            if (item.skillType == SkillAbility.Type.GeneralAttack)
            {
                skillAbilityManager.AddSkillAbility(new GeneralAttackSkillAbility(this, item));
            }
        }
    }

    /// <summary>
    /// 判断是否有有效的攻击目标
    /// </summary>
    /// <returns></returns>
    protected virtual bool IsHasTarget()
    {
        return false;
    }

    /// <summary>
    /// 是否满足普通攻击的条件
    /// </summary>
    /// <returns></returns>
    public override bool IsMeetGeneralAttackCondition()
    {
        return false;
    }

    /// <summary>
    /// 进入普通攻击动画状态
    /// </summary>
    public override void BeforeGeneralAttack()
    {

    }

    /// <summary>
    /// 普通攻击期间
    /// </summary>
    public override void OnGeneralAttack()
    {

    }

    /// <summary>
    /// 退出普通攻击的条件
    /// </summary>
    /// <returns></returns>
    public override bool IsMeetEndGeneralAttackCondition()
    {
        return false;
    }

    /// <summary>
    /// 退出普通攻击后要做的事
    /// </summary>
    public override void AfterGeneralAttack()
    {

    }

    /// <summary>
    /// 是否为伤害判定时刻（近战攻击为打出实际伤害，远程攻击为确定发射弹体）
    /// </summary>
    /// <returns></returns>
    public virtual bool IsDamageJudgment()
    {
        return false;
    }

    /// <summary>
    /// 执行具体的攻击，位于伤害判定为真之后
    /// </summary>
    public virtual void ExecuteDamage()
    {

    }

    // 在待机状态时每帧要做的事
    public override void OnIdleState()
    {

    }

    // 在攻击状态时每帧要做的事
    public override void OnAttackState()
    {

    }

    /// <summary>
    /// 死亡期间
    /// </summary>
    public override void DuringDeath()
    {
        DeathEvent();
    }

    /// <summary>
    /// 获取卡片所在的格子
    /// </summary>
    /// <returns></returns>
    public BaseGrid GetGrid()
    {
        return mGrid;
    }

    public void SetGrid(BaseGrid grid)
    {
        mGrid = grid;
    }

    /// <summary>
    /// 对于多格卡片请使用这个
    /// </summary>
    /// <returns></returns>
    public List<BaseGrid> GetGridList()
    {
        return mGridList;
    }

    /// <summary>
    /// 当与单位发生碰撞时能否阻挡的判定
    /// 默认是自身与老鼠同行时可以阻挡老鼠
    /// </summary>
    /// <param name="unit"></param>
    /// <returns></returns>
    public override bool CanBlock(BaseUnit unit)
    {
        if(unit is MouseUnit)
        {
            return GetRowIndex() == unit.GetRowIndex();
        }
        return false; // 别的单位暂时默认不能阻挡
    }

    /// <summary>
    /// 美食单位默认被处在同行的子弹击中
    /// </summary>
    /// <param name="bullet"></param>
    /// <returns></returns>
    public override bool CanHit(BaseBullet bullet)
    {
        return GetRowIndex() == bullet.GetRowIndex();
    }

    /// <summary>
    /// 状态相关
    /// </summary>
    public override void OnIdleStateEnter()
    {
        animator.Play("Idle");
    }

    public override void OnAttackStateEnter()
    {
        // 每次攻击时，最好根据攻速来计算一下播放速度，然后改变播放速度
        UpdateAttackAnimationSpeed();
        animator.Play("Attack");
    }

    public override void OnAttackStateExit()
    {
        // 攻击结束后播放速度改回来
        animator.speed = 1;
    }

    public override void OnAttackStateContinue()
    {
        // 每次攻击时，最好根据攻速来计算一下播放速度，然后改变播放速度
        UpdateAttackAnimationSpeed();
        // animator.Play("Attack", -1, currentStateTimer/ConfigManager.fps);
    }

    public override void OnDieStateEnter()
    {
        // 对于美食来说没有死亡动画的话，直接回收对象就行，在游戏里的体现就是直接消失，回收对象的事在duringDeath第一帧去做
    }

    public override void OnBurnStateEnter()
    {
        // 装上烧毁材质
        spriteRenderer1.material = GameManager.Instance.GetMaterial("Dissolve2");
        // 屏蔽星级特效
        spriteRenderer2.enabled = false;
        // 禁止播放动画
        AnimatorStop();
    }

    public override void DuringBurn(float _Threshold)
    {
        spriteRenderer1.material.SetFloat("_Threshold", _Threshold);
        // 超过1就可以回收了
        if (_Threshold >= 1.0)
        {
            DeathEvent();
        }
    }

    /// <summary>
    /// 根据攻击速度来更新攻击动画的速度
    /// </summary>
    private void UpdateAttackAnimationSpeed()
    {
        float time = AnimatorManager.GetClipTime(animator, "Attack"); // 1倍情况下，一次攻击的默认时间 秒
        float interval = 1/NumericBox.AttackSpeed.Value; // 攻击间隔  秒
        float rate = Mathf.Max(1, time / interval);
        AnimatorManager.SetClipSpeed(animator, "Attack", rate);
    }

    public static void SaveNewFoodInfo()
    {
        FoodUnit.Attribute attr = new FoodUnit.Attribute()
        {
            baseAttrbute = new BaseUnit.Attribute()
            {
                name = "终结者酒架", // 单位的具体名称
                type = 7, // 单位属于的分类
                shape = 2, // 单位在当前分类的变种编号

                baseHP = 50, // 基础血量
                baseAttack = 0, // 基础攻击
                baseAttackSpeed = 1.05, // 基础攻击速度
                attackPercent = 0.5,
                baseDefense = 0,
                baseMoveSpeed = 0,
                baseRange = 9,
                baseHeight = 0, // 基础高度
            },
            valueList = new float[] {10, 12, 14, 15, 18, 20, 22, 26, 32, 40, 55, 70, 85, 100, 115, 130, 145 },
            foodType = FoodType.Shooter
        };

        Debug.Log("开始存档美食信息！");
        JsonManager.Save(attr, "Food/" + attr.baseAttrbute.type + "/" + attr.baseAttrbute.shape + "");
        Debug.Log("美食信息存档完成！");
    }

    /// <summary>
    /// 设置渲染层级
    /// </summary>
    /// <param name="arrayIndex"></param>
    public override void UpdateRenderLayer(int arrayIndex)
    {
        spriteRenderer1.sortingOrder = LayerManager.CalculateSortingLayer(LayerManager.UnitType.Ally, GetRowIndex(), 0, 2*arrayIndex);
        spriteRenderer2.sortingOrder = LayerManager.CalculateSortingLayer(LayerManager.UnitType.Ally, GetRowIndex(), 0, 2*arrayIndex+1);
    }

    public override void AnimatorStop()
    {
        animator.speed = 0;
    }

    public override void AnimatorContinue()
    {
        animator.speed = 1;
    }

    // 死亡后，将自身信息从对应格子移除，以腾出空间给后续其他同格子分类型卡片使用
    public override void AfterDeath()
    {
        mGrid.RemoveFoodUnit(BaseCardBuilder.GetFoodInGridType(mType));
    }

}